Isomorphism

Что такое isomorphism? Для объяснения рассмотрим взаимодействие 2-ух множеств. Первое множество - целочисленные значения от минус бесконечности до плюс бесконечности. Второе множество - логические значения. Их всего два: True, False.

Кроме того, есть функция add, которая применяется к элементам из 1-ого множества - вычисление суммы.

``` scala
add(int, int) -> int
add(a, b) = a + b

add(2, 2) = 4
add(4, 4) = 8

```

Также существует функция, которая работает с логическими значениям, т.е. применяется к элеметам второго множества (инвертирует их).

``` scala
not(bool) -> bool
not(True) = False
not(False) = True

```

Теперь, давайте зададим вопрос, а можем ли мы передать в функцию add логические значения и наоборот в функцию not целочисленное.

``` scala
add(True, False)  ???
not(10) ???

```

Можем, но лишь в том случае, если сможем написать соответсвующие функции-трансляторы.

``` scala
toBool(int) -> bool
toBool(0) = False
toBool(_) = True

toInt(bool) -> int
toInt(True) = 1
toInt(False) = 0
```

И тут мы в плотную приблизились к понятию isomorpism. Isomorphism - это способность одного объекта участвовать в операции, которая ожидает другой объект. Транслируя написанное на пример выше, это возможность передать в not любое целочисленное значение, а в функцию add логическое, без поломки работоспособности кода. Дргуми словами мы расцениваем логические значения как целочисленные, а целочисленные как логические. Принято говорить, что логический и целочисленный set'ы идентичны вплоть до isomorphism'а. Они не могут расцениваться как полностью идентичные т.к. требуются функции helper'ы.

``` scala
add(toInt(True), toInt(False)) = 1
add(toInt(True), toInt(True)) = 2

not(toBool(10)) = True
not(toBool(0)) = False

```

Для закрепления появившихся интуиций. Рассмотрим еще одни пример.

Есть нижеследующая структура данных

``` scala

(int, string, string)

(1, "Surname1", "Name1")
(2, "Surname2", "Name2")
...
(n, "SurnameN", "NameN")
```

и некоторая функция которая на вход ожидает получить именно такую структуру данных и на ее основании выполнить какие-либо действия. Неважно какие, предалагаю абстрагироваться от этого. Но, что если мы передадим в эту функции, немного другое.

``` scala
(int, (string, string))
(1, ("Surname1", "Name1"))
(2, ("Surname2", "Name2"))
...
(n, ("SurnameN", "NameN"))

```

Можно ли считать варианты равнозначными. Человек мысленно отбрасывает скобки и переходит к сути структуры. С его точки зрения, 1-ый и 2-ой случаи содержат идентичную информацию. Дело в том, что он, как разумное существо, способен в уме написать функцию-парсер. Компьютеру в этом надо помочь. Таким образом, структура 1 и структура 2 идентичны, но лишь до isomorphism'а.
